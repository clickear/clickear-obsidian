


# 计算机组成与结构
## 计算机系统知识
### 计算机硬件组成

+ 运算器
+ 控制器
+ 存储器 (内部存储器（内存，容量小，速度快） 和外部存储器 (硬盘、光盘。容量大，速度慢))
+ 输入设备(鼠标、键盘)
+ 输出设备(显示器)

## 中英处理单元（CPU）

### cpu如何执行程序？
 1. cpu如何区分 0110 是地址还是数据还是指令？
看数据从哪里来，总线可分为3种类型
地址总线: 说明是地址
数据总线：说明是数据
控制总线:  说明是控制信号。比如控制是读还是写操作等。

2. 主存储器与cpu如何交互？
注意: MDR 是双向的。也就是可以读写。MAR是单向的

![](http://image.clickear.top/20220321102742.png)

### 指令周期
原则: 
+ 指令 = 操作码 + 操作数
+ 通过MAR --> 地址总线，来定位地址
+ 通过控制总线， --> 传输读/写信号
+ 通过MDR --> 数据总线 --> 主存 。进行数据交互
+ 1. PC （保存指令地址） --> MAR --> 地址总线 --> 定位到地址
+ 2. 控制信息，发送读信号。 主存 --> 数据总线 --> MDR --> IR(存放指令)
+ 3. CU发出指令 --> PC内容 +1

指令译码器，解析操作码。




#### 取指周期 (取指令)
![](http://image.clickear.top/20220321102203.png)
#### 间址周期(取操作数的有效地址)
![](http://image.clickear.top/20220321104444.png)

![](http://image.clickear.top/20220321110526.png)

#### 执行周期（取操作数）

#### 中断周期(为了保程序断点)


cpu(运算器 + 控制器 + 寄存器组 + 内部总线)

cpu功能: 实现 程序控制、操作控制、时间控制、数据处理功能

### 运算器:
功能: 
执行所有的算术运算、加减乘除。执行位运算
#### 算术逻辑单元 ALU
实现对数据的算术和逻辑运算
#### 累积寄存器AC: 
运算结果或源操作数的存放区
#### 数据缓存寄存器(DR)
暂时存放内存的指令或数据
#### 状态条件寄存器
保存指令结果的条件吗内容，如溢出标志


### 控制器⭐
功能:
程序控制、时序控制
#### 指令寄存器IR: 
暂存CPU执行指令
#### 程序计数器PC: 
存放指令执行地址
#### 地址寄存器AR: 
保存当前CPU所访问的内存地址
#### 指令译码器ID: 
分析指令操作码等组成


## 寻址方式 ⭐
![](http://image.clickear.top/20220321101819.png)


直接寻址 --> [500] = 800
立即寻址 --> 500
间接寻址 --> [ [500]] = [800] =300
相对寻址 --> [500 + 2 + 200] = [702] = 325
变址寻址 --> [ XR + 500 ] = [600] = 900
寄存器寻址 --> 400
寄存器间接寻址 --> [ 400 ] = 700


## 数据表示
在计算机中的表示，在计算机中，都是二进制

## 数的编码方式
+ 补码和移码，0是一样的。所以可以表示的数多一位。但是这多的一位，其实是负数的没太大意义。
+ 补码的补码 = 原码

原码： +0 和 -0;
反码: 正数的反码 = 原码 。 负数的原码: 除符号位外，其它各位按位取反。
+0 (0 0000000); -0(1 1111111)
补码: 正数的补码 = 原码。 负数的补码 在原码基础上，除符号位外，其它各位按位取反，而后末位 +1; +0 = -0 = (00000000)
移码: 用作浮点运算。无论正负数，都是将该原码的补码的首位(符号位)取反得到移码。

### 数的范围: 
+ 为什么补码负数会多一位？因为补码没有区分 +0 和 -0。也就是说 1000，0000 这个码不用就浪费了。
+ 符合规定值。将该负数取绝对值,再用二进制表示出这个绝对值 (不管符号位！）对该二进制数进行取反加一操作就得到负数的补码了 （也就是求补操作!）
	+ 为128的二进制表示为:1000 0000 
	+ 取反 0111 1111
	+ 加1  1000 0000
这就是-128的补码
这种办法算出的结果符合“规定值”.
![[Pasted image 20220321143157.png]]


## 浮点数的标识 ⭐
浮点数: N= F * 2^E;    E 是阶码， F称为尾数。
数值<font color=#ff0000>范围</font>由<font color=#ff0000>阶码</font>确定，数值的<font color=#ff0000>精度</font>是由<font color=#ff0000>尾数</font>确定

规格化 尾数
1.0 负数 0.1xxxx 正数

浮点数运算:
1. <font color=#ff0000>对阶</font>，小阶向大阶看起。尾数较少。尾数右移几位。
2. 尾数计算(相加，若是减运算，则加负数)
3. 结果规格化(即尾数表示规格化)

## 算术运算和逻辑运算(运算器的作用)
算术运算: 加减乘除
逻辑运算: & | 异或 非 <<左移 >> 右移。 会舍弃


## 校验码
码距: 在2个编码中，从A码到B码所需要改变的位数。如 A:00 变成B: 11。码距为2.<font color=#ff0000>一般码距越大，越有利于纠错和检测</font>。

### 奇偶校验
+ 奇偶校验 (只能检错，不能纠错。可以检出<font color=#ff0000>1</font>位): 在编码中，增加1位校验位来使编码中1的个数为奇数、或偶数。只能检<font color=#ff0000>1</font>位错。
为了使得1的个数是奇数或者偶数。


### 循环冗余校验码 (CRC)
+ 循环冗余校验码 (CRC，只能检错，不能纠错。可以检出<font color=#ff0000>多</font>位)。
![[Pasted image 20220321160040.png]]


### 海明校验码(利用奇偶性来检查和纠错, ) ⭐
[《汉明码（海明码）》通俗易懂_苏某的橡皮擦的博客-CSDN博客](https://blog.csdn.net/weixin_61985100/article/details/123300540)

2<sup>k</sup> -1 >=  n+k。 其中k为校验码的位数，k为信息的位数。
怎么理解这个公式？ 首先，校验码可以指示出哪些有问题，即2<sup>k</sup>.那为什么要减-1呢？因为0代表的是没有错误。所以除0外，才是校验码能表示的数字。比如校验码为3位，我们可以认为000，是无错误。 001 是第一位出错等。
那么很好理解，这个公式了。

原理: 
![[Pasted image 20220321175757.png]]
—：1，2，3，4
二：6，2，5，4
三：6，7，3，4                       
要记住只能错一个数字的情况哇，（下面会讲为啥是纠正一个错误，检查出两个错误的）
那么我们来看几种情况：
（1）如果第一组错误了，而第二第三组没有错误，是不是就排除了第二第三组的2，3，4，5，6，7了呢。所以错误是不是就是确定是1区域错了。
（2）如果第一第二组错了，而第三组没有错，看上图，只有一个是错误的话那就是结果2了。
（3）同理三组都错，是不是就确定了是4区域错了
这里，只是举例检错原理



## 计算机体系结构
## 计算机体系分类

flynn分类
指令流、数据流来进行分类。

指令流， 控制部分。 多个指导
数据流， 处理器。    处理事情
主存模块，只有有多就是多。


## 计算机指令
计算机指令组成:  操作码和操作数组成。

取指令--> 分析指令 --> 执行指令

|                | RISC                           | CISC                              |
| -------------- | ------------------------------ | --------------------------------- |
| 指令种类       | 少，精简                       | 多，丰富                          |
| 指令复杂度     | 低，简单                       | 高，复杂                          |
| 指令长度       | 固定                           | 变化                              |
| 寻址方式       | 少                             | 多                                |
| 实现译码方式   | 硬布线控制逻辑(组合逻辑控制器) | 微程序控制技术                    |
| 通用寄存器数量 | 多，大量                       | 少                                |
| 流水线技术     | 支持                           | <font color=#ff0000>不支持</font> |


## 指令流水线 ⭐
+ 流水线周期: 指令分成不同阶段，<font color=#ff0000>执行时间最长的段位流水线周期</font>
+ 流水线执行时间: <font color=#ff0000>1条指令总执行时间 + (总指令条数-1) * 流水线周期</font>
+ 执行n条指令的吞吐率 = n/流水线执行时间 
+ 单位时间的流水线吞吐率 = 1/流水线周期
+ 加速比= 不使用流水线时间/ 使用流水线时间

## 存储系统
存储容量、成本和速度的矛盾问题。
cpu --> 通用寄存器 --> cache --> 主存 --> 磁盘 

半导体: 
动态存储器(周期刷， 可随机访问， 主存是动态构成的)
静态存储器(顺序访问 , cache是sam构成的)

相联存储器，是按内容访问的存储器。
虚拟存储器，是主存和辅存组成的。

### 主存编址
![[Pasted image 20220322085728.png]]



### 局部性原理
时间局部性原理： 相邻的时间内会访问同一个数据项
空间局部性原理: 相邻的空间地址会被连续访问

## 高速缓存cache(对程序员透明，由硬件自动完成映射)

地址映射：在cpu工作时，都是根据主存单位的地址。需要进行映射，是由<font color=#ff0000>硬件自动完成映射</font>。
+ 直接映射:  冲突最大
+ 全相连映射: 冲突最小
+ 组组相连映射:  冲突中等

## cachae命令率

2^10 = 1024



## 总线结构

数据总线:  地址总线的宽度与数据字长一致。
地址总线: 2<sup>32</sup> 代表4gb的内存。
控制总线

串行: 低速、长距离
并行: 高速、短距离

半双工: 同一时刻只能一个方向传输
全双工: 同一时刻，可以双向传输

## 系统可靠性分析 ⭐


## 中断
1. 中断向量表，提供中断服务程序入口地址。
2. 中断响应时间:  中断请求开始，进入中断服务程序程序
3. 保护现场，返回来执行原程序。
4. 多级中断嵌套，使用堆栈来保护断点和现场最有效。
5. 中断是来自处理器外部的请求事件，异常是指令执行过程中在处理器内部发送的特殊事件。

## 输入输出（IO）控制方式
### 程序查询方式(轮询)
1. <font color=#ff0000>CPU和IO只能串行工作</font>。cpu需要一直检查，利用率低。
2. 一次只能读/写一个字
3. 由CPU将数放入内存
### 中断驱动方式(中断)
1. I/O设备通过中断信号主动报告IO已完成
2. <font color=#ff0000>CPU和IO可并行工作</font>
3. cpu利用率得到提高
4. 由cpu将数据放入内存
5. 一次只能读/写一个字
### 直接存储方式(DMA)⭐
1. <font color=#ff0000>cpu和io可并行工作</font>
2. 仅在传送<font color=#ff0000>数据块</font>的<font color=#ff0000>开始和结束</font>时，才需要cpu干预
3. 由<font color=#ff0000>外设直接</font>将数据放入内存（主存）
4. 一次读写的单位是"块"，而不是字